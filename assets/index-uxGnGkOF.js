(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const i of r)if(i.type==="childList")for(const c of i.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function n(r){const i={};return r.integrity&&(i.integrity=r.integrity),r.referrerPolicy&&(i.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?i.credentials="include":r.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function s(r){if(r.ep)return;r.ep=!0;const i=n(r);fetch(r.href,i)}})();function re(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function he(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function Re(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");re(t.outputLen),re(t.blockLen)}function Et(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Me(t,e){he(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const Ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const de=t=>t instanceof Uint8Array,Lt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),G=(t,e)=>t<<32-e|t>>>e,Ve=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ve)throw new Error("Non little-endian hardware is not supported");function ze(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function jt(t){if(typeof t=="string"&&(t=ze(t)),!de(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Ze(...t){const e=new Uint8Array(t.reduce((s,r)=>s+r.length,0));let n=0;return t.forEach(s=>{if(!de(s))throw new Error("Uint8Array expected");e.set(s,n),n+=s.length}),e}let ge=class{clone(){return this._cloneInto()}};function We(t){const e=s=>t().update(jt(s)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function be(t=32){if(Ut&&typeof Ut.getRandomValues=="function")return Ut.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function Ke(t,e,n,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,s);const r=BigInt(32),i=BigInt(4294967295),c=Number(n>>r&i),o=Number(n&i),a=s?4:0,f=s?0:4;t.setUint32(e+a,c,s),t.setUint32(e+f,o,s)}let Ge=class extends ge{constructor(e,n,s,r){super(),this.blockLen=e,this.outputLen=n,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=Lt(this.buffer)}update(e){Et(this);const{view:n,buffer:s,blockLen:r}=this;e=jt(e);const i=e.length;for(let c=0;c<i;){const o=Math.min(r-this.pos,i-c);if(o===r){const a=Lt(e);for(;r<=i-c;c+=r)this.process(a,c);continue}s.set(e.subarray(c,c+o),this.pos),this.pos+=o,c+=o,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Et(this),Me(e,this),this.finished=!0;const{buffer:n,view:s,blockLen:r,isLE:i}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>r-c&&(this.process(s,0),c=0);for(let u=c;u<r;u++)n[u]=0;Ke(s,r-8,BigInt(this.length*8),i),this.process(s,0);const o=Lt(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,h=this.get();if(f>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)o.setUint32(4*u,h[u],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const s=e.slice(0,n);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:s,length:r,finished:i,destroyed:c,pos:o}=this;return e.length=r,e.pos=o,e.finished=i,e.destroyed=c,r%n&&e.buffer.set(s),e}};const je=(t,e,n)=>t&e^~t&n,De=(t,e,n)=>t&e^t&n^e&n,Fe=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),X=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),tt=new Uint32Array(64);let Ye=class extends Ge{constructor(){super(64,32,8,!1),this.A=X[0]|0,this.B=X[1]|0,this.C=X[2]|0,this.D=X[3]|0,this.E=X[4]|0,this.F=X[5]|0,this.G=X[6]|0,this.H=X[7]|0}get(){const{A:e,B:n,C:s,D:r,E:i,F:c,G:o,H:a}=this;return[e,n,s,r,i,c,o,a]}set(e,n,s,r,i,c,o,a){this.A=e|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=i|0,this.F=c|0,this.G=o|0,this.H=a|0}process(e,n){for(let u=0;u<16;u++,n+=4)tt[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const y=tt[u-15],x=tt[u-2],p=G(y,7)^G(y,18)^y>>>3,l=G(x,17)^G(x,19)^x>>>10;tt[u]=l+tt[u-7]+p+tt[u-16]|0}let{A:s,B:r,C:i,D:c,E:o,F:a,G:f,H:h}=this;for(let u=0;u<64;u++){const y=G(o,6)^G(o,11)^G(o,25),x=h+y+je(o,a,f)+Fe[u]+tt[u]|0,l=(G(s,2)^G(s,13)^G(s,22))+De(s,r,i)|0;h=f,f=a,a=o,o=c+x|0,c=i,i=r,r=s,s=x+l|0}s=s+this.A|0,r=r+this.B|0,i=i+this.C|0,c=c+this.D|0,o=o+this.E|0,a=a+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(s,r,i,c,o,a,f,h)}roundClean(){tt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const Mt=We(()=>new Ye);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const we=BigInt(0),At=BigInt(1),Qe=BigInt(2),It=t=>t instanceof Uint8Array,Je=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function ht(t){if(!It(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Je[t[n]];return e}function ye(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function Dt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function dt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let s=0;s<n.length;s++){const r=s*2,i=t.slice(r,r+2),c=Number.parseInt(i,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");n[s]=c}return n}function q(t){return Dt(ht(t))}function Ft(t){if(!It(t))throw new Error("Uint8Array expected");return Dt(ht(Uint8Array.from(t).reverse()))}function st(t,e){return dt(t.toString(16).padStart(e*2,"0"))}function Yt(t,e){return st(t,e).reverse()}function Xe(t){return dt(ye(t))}function k(t,e,n){let s;if(typeof e=="string")try{s=dt(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(It(e))s=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const r=s.length;if(typeof n=="number"&&r!==n)throw new Error(`${t} expected ${n} bytes, got ${r}`);return s}function at(...t){const e=new Uint8Array(t.reduce((s,r)=>s+r.length,0));let n=0;return t.forEach(s=>{if(!It(s))throw new Error("Uint8Array expected");e.set(s,n),n+=s.length}),e}function tn(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function en(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function nn(t){let e;for(e=0;t>we;t>>=At,e+=1);return e}function sn(t,e){return t>>BigInt(e)&At}const rn=(t,e,n)=>t|(n?At:we)<<BigInt(e),Qt=t=>(Qe<<BigInt(t-1))-At,Nt=t=>new Uint8Array(t),ie=t=>Uint8Array.from(t);function pe(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let s=Nt(t),r=Nt(t),i=0;const c=()=>{s.fill(1),r.fill(0),i=0},o=(...u)=>n(r,s,...u),a=(u=Nt())=>{r=o(ie([0]),u),s=o(),u.length!==0&&(r=o(ie([1]),u),s=o())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const y=[];for(;u<e;){s=o();const x=s.slice();y.push(x),u+=s.length}return at(...y)};return(u,y)=>{c(),a(u);let x;for(;!(x=y(f()));)a();return c(),x}}const on={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function pt(t,e,n={}){const s=(r,i,c)=>{const o=on[i];if(typeof o!="function")throw new Error(`Invalid validator "${i}", expected function`);const a=t[r];if(!(c&&a===void 0)&&!o(a,t))throw new Error(`Invalid param ${String(r)}=${a} (${typeof a}), expected ${i}`)};for(const[r,i]of Object.entries(e))s(r,i,!1);for(const[r,i]of Object.entries(n))s(r,i,!0);return t}const cn=Object.freeze(Object.defineProperty({__proto__:null,bitGet:sn,bitLen:nn,bitMask:Qt,bitSet:rn,bytesToHex:ht,bytesToNumberBE:q,bytesToNumberLE:Ft,concatBytes:at,createHmacDrbg:pe,ensureBytes:k,equalBytes:tn,hexToBytes:dt,hexToNumber:Dt,numberToBytesBE:st,numberToBytesLE:Yt,numberToHexUnpadded:ye,numberToVarBytesBE:Xe,utf8ToBytes:en,validateObject:pt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _=BigInt(0),L=BigInt(1),ot=BigInt(2),an=BigInt(3),Vt=BigInt(4),oe=BigInt(5),ce=BigInt(8);BigInt(9);BigInt(16);function P(t,e){const n=t%e;return n>=_?n:e+n}function un(t,e,n){if(n<=_||e<_)throw new Error("Expected power/modulo > 0");if(n===L)return _;let s=L;for(;e>_;)e&L&&(s=s*t%n),t=t*t%n,e>>=L;return s}function Z(t,e,n){let s=t;for(;e-- >_;)s*=s,s%=n;return s}function zt(t,e){if(t===_||e<=_)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=P(t,e),s=e,r=_,i=L;for(;n!==_;){const o=s/n,a=s%n,f=r-i*o;s=n,n=a,r=i,i=f}if(s!==L)throw new Error("invert: does not exist");return P(r,e)}function fn(t){const e=(t-L)/ot;let n,s,r;for(n=t-L,s=0;n%ot===_;n/=ot,s++);for(r=ot;r<t&&un(r,e,t)!==t-L;r++);if(s===1){const c=(t+L)/Vt;return function(a,f){const h=a.pow(f,c);if(!a.eql(a.sqr(h),f))throw new Error("Cannot find square root");return h}}const i=(n+L)/ot;return function(o,a){if(o.pow(a,e)===o.neg(o.ONE))throw new Error("Cannot find square root");let f=s,h=o.pow(o.mul(o.ONE,r),n),u=o.pow(a,i),y=o.pow(a,n);for(;!o.eql(y,o.ONE);){if(o.eql(y,o.ZERO))return o.ZERO;let x=1;for(let l=o.sqr(y);x<f&&!o.eql(l,o.ONE);x++)l=o.sqr(l);const p=o.pow(h,L<<BigInt(f-x-1));h=o.sqr(p),u=o.mul(u,p),y=o.mul(y,h),f=x}return u}}function ln(t){if(t%Vt===an){const e=(t+L)/Vt;return function(s,r){const i=s.pow(r,e);if(!s.eql(s.sqr(i),r))throw new Error("Cannot find square root");return i}}if(t%ce===oe){const e=(t-oe)/ce;return function(s,r){const i=s.mul(r,ot),c=s.pow(i,e),o=s.mul(r,c),a=s.mul(s.mul(o,ot),c),f=s.mul(o,s.sub(a,s.ONE));if(!s.eql(s.sqr(f),r))throw new Error("Cannot find square root");return f}}return fn(t)}const hn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function dn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=hn.reduce((s,r)=>(s[r]="function",s),e);return pt(t,n)}function gn(t,e,n){if(n<_)throw new Error("Expected power > 0");if(n===_)return t.ONE;if(n===L)return e;let s=t.ONE,r=e;for(;n>_;)n&L&&(s=t.mul(s,r)),r=t.sqr(r),n>>=L;return s}function bn(t,e){const n=new Array(e.length),s=e.reduce((i,c,o)=>t.is0(c)?i:(n[o]=i,t.mul(i,c)),t.ONE),r=t.inv(s);return e.reduceRight((i,c,o)=>t.is0(c)?i:(n[o]=t.mul(i,n[o]),t.mul(i,c)),r),n}function me(t,e){const n=e!==void 0?e:t.toString(2).length,s=Math.ceil(n/8);return{nBitLength:n,nByteLength:s}}function wn(t,e,n=!1,s={}){if(t<=_)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:r,nByteLength:i}=me(t,e);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=ln(t),o=Object.freeze({ORDER:t,BITS:r,BYTES:i,MASK:Qt(r),ZERO:_,ONE:L,create:a=>P(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return _<=a&&a<t},is0:a=>a===_,isOdd:a=>(a&L)===L,neg:a=>P(-a,t),eql:(a,f)=>a===f,sqr:a=>P(a*a,t),add:(a,f)=>P(a+f,t),sub:(a,f)=>P(a-f,t),mul:(a,f)=>P(a*f,t),pow:(a,f)=>gn(o,a,f),div:(a,f)=>P(a*zt(f,t),t),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>zt(a,t),sqrt:s.sqrt||(a=>c(o,a)),invertBatch:a=>bn(o,a),cmov:(a,f,h)=>h?f:a,toBytes:a=>n?Yt(a,i):st(a,i),fromBytes:a=>{if(a.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${a.length}`);return n?Ft(a):q(a)}});return Object.freeze(o)}function xe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Ee(t){const e=xe(t);return e+Math.ceil(e/2)}function yn(t,e,n=!1){const s=t.length,r=xe(e),i=Ee(e);if(s<16||s<i||s>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${s}`);const c=n?q(t):Ft(t),o=P(c,e-L)+L;return n?Yt(o,r):st(o,r)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const pn=BigInt(0),_t=BigInt(1);function mn(t,e){const n=(r,i)=>{const c=i.negate();return r?c:i},s=r=>{const i=Math.ceil(e/r)+1,c=2**(r-1);return{windows:i,windowSize:c}};return{constTimeNegate:n,unsafeLadder(r,i){let c=t.ZERO,o=r;for(;i>pn;)i&_t&&(c=c.add(o)),o=o.double(),i>>=_t;return c},precomputeWindow(r,i){const{windows:c,windowSize:o}=s(i),a=[];let f=r,h=f;for(let u=0;u<c;u++){h=f,a.push(h);for(let y=1;y<o;y++)h=h.add(f),a.push(h);f=h.double()}return a},wNAF(r,i,c){const{windows:o,windowSize:a}=s(r);let f=t.ZERO,h=t.BASE;const u=BigInt(2**r-1),y=2**r,x=BigInt(r);for(let p=0;p<o;p++){const l=p*a;let g=Number(c&u);c>>=x,g>a&&(g-=y,c+=_t);const b=l,E=l+Math.abs(g)-1,B=p%2!==0,T=g<0;g===0?h=h.add(n(B,i[b])):f=f.add(n(T,i[E]))}return{p:f,f:h}},wNAFCached(r,i,c,o){const a=r._WINDOW_SIZE||1;let f=i.get(r);return f||(f=this.precomputeWindow(r,a),a!==1&&i.set(r,o(f))),this.wNAF(a,f,c)}}}function ve(t){return dn(t.Fp),pt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...me(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function xn(t){const e=ve(t);pt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:s,a:r}=e;if(n){if(!s.eql(r,s.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:En,hexToBytes:vn}=cn,ct={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=ct;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],s=t.subarray(2,n+2);if(!n||s.length!==n)throw new e("Invalid signature integer: wrong length");if(s[0]&128)throw new e("Invalid signature integer: negative");if(s[0]===0&&!(s[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:En(s),l:t.subarray(n+2)}},toSig(t){const{Err:e}=ct,n=typeof t=="string"?vn(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let s=n.length;if(s<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==s-2)throw new e("Invalid signature: incorrect length");const{d:r,l:i}=ct._parseInt(n.subarray(2)),{d:c,l:o}=ct._parseInt(i);if(o.length)throw new e("Invalid signature: left bytes after parsing");return{r,s:c}},hexFromSig(t){const e=f=>Number.parseInt(f[0],16)&8?"00"+f:f,n=f=>{const h=f.toString(16);return h.length&1?`0${h}`:h},s=e(n(t.s)),r=e(n(t.r)),i=s.length/2,c=r.length/2,o=n(i),a=n(c);return`30${n(c+i+4)}02${a}${r}02${o}${s}`}},D=BigInt(0),W=BigInt(1);BigInt(2);const ae=BigInt(3);BigInt(4);function Bn(t){const e=xn(t),{Fp:n}=e,s=e.toBytes||((p,l,g)=>{const b=l.toAffine();return at(Uint8Array.from([4]),n.toBytes(b.x),n.toBytes(b.y))}),r=e.fromBytes||(p=>{const l=p.subarray(1),g=n.fromBytes(l.subarray(0,n.BYTES)),b=n.fromBytes(l.subarray(n.BYTES,2*n.BYTES));return{x:g,y:b}});function i(p){const{a:l,b:g}=e,b=n.sqr(p),E=n.mul(b,p);return n.add(n.add(E,n.mul(p,l)),g)}if(!n.eql(n.sqr(e.Gy),i(e.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return typeof p=="bigint"&&D<p&&p<e.n}function o(p){if(!c(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(p){const{allowedPrivateKeyLengths:l,nByteLength:g,wrapPrivateKey:b,n:E}=e;if(l&&typeof p!="bigint"){if(p instanceof Uint8Array&&(p=ht(p)),typeof p!="string"||!l.includes(p.length))throw new Error("Invalid key");p=p.padStart(g*2,"0")}let B;try{B=typeof p=="bigint"?p:q(k("private key",p,g))}catch{throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`)}return b&&(B=P(B,E)),o(B),B}const f=new Map;function h(p){if(!(p instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,g,b){if(this.px=l,this.py=g,this.pz=b,l==null||!n.isValid(l))throw new Error("x required");if(g==null||!n.isValid(g))throw new Error("y required");if(b==null||!n.isValid(b))throw new Error("z required")}static fromAffine(l){const{x:g,y:b}=l||{};if(!l||!n.isValid(g)||!n.isValid(b))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const E=B=>n.eql(B,n.ZERO);return E(g)&&E(b)?u.ZERO:new u(g,b,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const g=n.invertBatch(l.map(b=>b.pz));return l.map((b,E)=>b.toAffine(g[E])).map(u.fromAffine)}static fromHex(l){const g=u.fromAffine(r(k("pointHex",l)));return g.assertValidity(),g}static fromPrivateKey(l){return u.BASE.multiply(a(l))}_setWindowSize(l){this._WINDOW_SIZE=l,f.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:g}=this.toAffine();if(!n.isValid(l)||!n.isValid(g))throw new Error("bad point: x or y not FE");const b=n.sqr(g),E=i(l);if(!n.eql(b,E))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(n.isOdd)return!n.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){h(l);const{px:g,py:b,pz:E}=this,{px:B,py:T,pz:I}=l,m=n.eql(n.mul(g,I),n.mul(B,E)),v=n.eql(n.mul(b,I),n.mul(T,E));return m&&v}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:l,b:g}=e,b=n.mul(g,ae),{px:E,py:B,pz:T}=this;let I=n.ZERO,m=n.ZERO,v=n.ZERO,A=n.mul(E,E),z=n.mul(B,B),U=n.mul(T,T),H=n.mul(E,B);return H=n.add(H,H),v=n.mul(E,T),v=n.add(v,v),I=n.mul(l,v),m=n.mul(b,U),m=n.add(I,m),I=n.sub(z,m),m=n.add(z,m),m=n.mul(I,m),I=n.mul(H,I),v=n.mul(b,v),U=n.mul(l,U),H=n.sub(A,U),H=n.mul(l,H),H=n.add(H,v),v=n.add(A,A),A=n.add(v,A),A=n.add(A,U),A=n.mul(A,H),m=n.add(m,A),U=n.mul(B,T),U=n.add(U,U),A=n.mul(U,H),I=n.sub(I,A),v=n.mul(U,z),v=n.add(v,v),v=n.add(v,v),new u(I,m,v)}add(l){h(l);const{px:g,py:b,pz:E}=this,{px:B,py:T,pz:I}=l;let m=n.ZERO,v=n.ZERO,A=n.ZERO;const z=e.a,U=n.mul(e.b,ae);let H=n.mul(g,B),C=n.mul(b,T),R=n.mul(E,I),F=n.add(g,b),d=n.add(B,T);F=n.mul(F,d),d=n.add(H,C),F=n.sub(F,d),d=n.add(g,E);let w=n.add(B,I);return d=n.mul(d,w),w=n.add(H,R),d=n.sub(d,w),w=n.add(b,E),m=n.add(T,I),w=n.mul(w,m),m=n.add(C,R),w=n.sub(w,m),A=n.mul(z,d),m=n.mul(U,R),A=n.add(m,A),m=n.sub(C,A),A=n.add(C,A),v=n.mul(m,A),C=n.add(H,H),C=n.add(C,H),R=n.mul(z,R),d=n.mul(U,d),C=n.add(C,R),R=n.sub(H,R),R=n.mul(z,R),d=n.add(d,R),H=n.mul(C,d),v=n.add(v,H),H=n.mul(w,d),m=n.mul(F,m),m=n.sub(m,H),H=n.mul(F,C),A=n.mul(w,A),A=n.add(A,H),new u(m,v,A)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return x.wNAFCached(this,f,l,g=>{const b=n.invertBatch(g.map(E=>E.pz));return g.map((E,B)=>E.toAffine(b[B])).map(u.fromAffine)})}multiplyUnsafe(l){const g=u.ZERO;if(l===D)return g;if(o(l),l===W)return this;const{endo:b}=e;if(!b)return x.unsafeLadder(this,l);let{k1neg:E,k1:B,k2neg:T,k2:I}=b.splitScalar(l),m=g,v=g,A=this;for(;B>D||I>D;)B&W&&(m=m.add(A)),I&W&&(v=v.add(A)),A=A.double(),B>>=W,I>>=W;return E&&(m=m.negate()),T&&(v=v.negate()),v=new u(n.mul(v.px,b.beta),v.py,v.pz),m.add(v)}multiply(l){o(l);let g=l,b,E;const{endo:B}=e;if(B){const{k1neg:T,k1:I,k2neg:m,k2:v}=B.splitScalar(g);let{p:A,f:z}=this.wNAF(I),{p:U,f:H}=this.wNAF(v);A=x.constTimeNegate(T,A),U=x.constTimeNegate(m,U),U=new u(n.mul(U.px,B.beta),U.py,U.pz),b=A.add(U),E=z.add(H)}else{const{p:T,f:I}=this.wNAF(g);b=T,E=I}return u.normalizeZ([b,E])[0]}multiplyAndAddUnsafe(l,g,b){const E=u.BASE,B=(I,m)=>m===D||m===W||!I.equals(E)?I.multiplyUnsafe(m):I.multiply(m),T=B(this,g).add(B(l,b));return T.is0()?void 0:T}toAffine(l){const{px:g,py:b,pz:E}=this,B=this.is0();l==null&&(l=B?n.ONE:n.inv(E));const T=n.mul(g,l),I=n.mul(b,l),m=n.mul(E,l);if(B)return{x:n.ZERO,y:n.ZERO};if(!n.eql(m,n.ONE))throw new Error("invZ was invalid");return{x:T,y:I}}isTorsionFree(){const{h:l,isTorsionFree:g}=e;if(l===W)return!0;if(g)return g(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:g}=e;return l===W?this:g?g(u,this):this.multiplyUnsafe(e.h)}toRawBytes(l=!0){return this.assertValidity(),s(u,this,l)}toHex(l=!0){return ht(this.toRawBytes(l))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const y=e.nBitLength,x=mn(u,e.endo?Math.ceil(y/2):y);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:c}}function Sn(t){const e=ve(t);return pt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function An(t){const e=Sn(t),{Fp:n,n:s}=e,r=n.BYTES+1,i=2*n.BYTES+1;function c(d){return D<d&&d<n.ORDER}function o(d){return P(d,s)}function a(d){return zt(d,s)}const{ProjectivePoint:f,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:y}=Bn({...e,toBytes(d,w,S){const $=w.toAffine(),O=n.toBytes($.x),N=at;return S?N(Uint8Array.from([w.hasEvenY()?2:3]),O):N(Uint8Array.from([4]),O,n.toBytes($.y))},fromBytes(d){const w=d.length,S=d[0],$=d.subarray(1);if(w===r&&(S===2||S===3)){const O=q($);if(!c(O))throw new Error("Point is not on curve");const N=u(O);let M=n.sqrt(N);const V=(M&W)===W;return(S&1)===1!==V&&(M=n.neg(M)),{x:O,y:M}}else if(w===i&&S===4){const O=n.fromBytes($.subarray(0,n.BYTES)),N=n.fromBytes($.subarray(n.BYTES,2*n.BYTES));return{x:O,y:N}}else throw new Error(`Point of length ${w} was invalid. Expected ${r} compressed bytes or ${i} uncompressed bytes`)}}),x=d=>ht(st(d,e.nByteLength));function p(d){const w=s>>W;return d>w}function l(d){return p(d)?o(-d):d}const g=(d,w,S)=>q(d.slice(w,S));class b{constructor(w,S,$){this.r=w,this.s=S,this.recovery=$,this.assertValidity()}static fromCompact(w){const S=e.nByteLength;return w=k("compactSignature",w,S*2),new b(g(w,0,S),g(w,S,2*S))}static fromDER(w){const{r:S,s:$}=ct.toSig(k("DER",w));return new b(S,$)}assertValidity(){if(!y(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!y(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(w){return new b(this.r,this.s,w)}recoverPublicKey(w){const{r:S,s:$,recovery:O}=this,N=v(k("msgHash",w));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const M=O===2||O===3?S+e.n:S;if(M>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const V=(O&1)===0?"02":"03",Y=f.fromHex(V+x(M)),Q=a(M),ut=o(-N*Q),gt=o($*Q),J=f.BASE.multiplyAndAddUnsafe(Y,ut,gt);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return dt(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return dt(this.toCompactHex())}toCompactHex(){return x(this.r)+x(this.s)}}const E={isValidPrivateKey(d){try{return h(d),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const d=Ee(e.n);return yn(e.randomBytes(d),e.n)},precompute(d=8,w=f.BASE){return w._setWindowSize(d),w.multiply(BigInt(3)),w}};function B(d,w=!0){return f.fromPrivateKey(d).toRawBytes(w)}function T(d){const w=d instanceof Uint8Array,S=typeof d=="string",$=(w||S)&&d.length;return w?$===r||$===i:S?$===2*r||$===2*i:d instanceof f}function I(d,w,S=!0){if(T(d))throw new Error("first arg must be private key");if(!T(w))throw new Error("second arg must be public key");return f.fromHex(w).multiply(h(d)).toRawBytes(S)}const m=e.bits2int||function(d){const w=q(d),S=d.length*8-e.nBitLength;return S>0?w>>BigInt(S):w},v=e.bits2int_modN||function(d){return o(m(d))},A=Qt(e.nBitLength);function z(d){if(typeof d!="bigint")throw new Error("bigint expected");if(!(D<=d&&d<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return st(d,e.nByteLength)}function U(d,w,S=H){if(["recovered","canonical"].some(rt=>rt in S))throw new Error("sign() legacy options not supported");const{hash:$,randomBytes:O}=e;let{lowS:N,prehash:M,extraEntropy:V}=S;N==null&&(N=!0),d=k("msgHash",d),M&&(d=k("prehashed msgHash",$(d)));const Y=v(d),Q=h(w),ut=[z(Q),z(Y)];if(V!=null){const rt=V===!0?O(n.BYTES):V;ut.push(k("extraEntropy",rt))}const gt=at(...ut),J=Y;function $t(rt){const ft=m(rt);if(!y(ft))return;const ee=a(ft),K=f.BASE.multiply(ft).toAffine(),lt=o(K.x);if(lt===D)return;const mt=o(ee*o(J+lt*Q));if(mt===D)return;let ne=(K.x===lt?0:2)|Number(K.y&W),se=mt;return N&&p(mt)&&(se=l(mt),ne^=1),new b(lt,se,ne)}return{seed:gt,k2sig:$t}}const H={lowS:e.lowS,prehash:!1},C={lowS:e.lowS,prehash:!1};function R(d,w,S=H){const{seed:$,k2sig:O}=U(d,w,S),N=e;return pe(N.hash.outputLen,N.nByteLength,N.hmac)($,O)}f.BASE._setWindowSize(8);function F(d,w,S,$=C){const O=d;if(w=k("msgHash",w),S=k("publicKey",S),"strict"in $)throw new Error("options.strict was renamed to lowS");const{lowS:N,prehash:M}=$;let V,Y;try{if(typeof O=="string"||O instanceof Uint8Array)try{V=b.fromDER(O)}catch(K){if(!(K instanceof ct.Err))throw K;V=b.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:K,s:lt}=O;V=new b(K,lt)}else throw new Error("PARSE");Y=f.fromHex(S)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(N&&V.hasHighS())return!1;M&&(w=e.hash(w));const{r:Q,s:ut}=V,gt=v(w),J=a(ut),$t=o(gt*J),rt=o(Q*J),ft=f.BASE.multiplyAndAddUnsafe(Y,$t,rt)?.toAffine();return ft?o(ft.x)===Q:!1}return{CURVE:e,getPublicKey:B,getSharedSecret:I,sign:R,verify:F,ProjectivePoint:f,Signature:b,utils:E}}class Be extends ge{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,Re(e);const s=jt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const r=this.blockLen,i=new Uint8Array(r);i.set(s.length>r?e.create().update(s).digest():s);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=e.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(e){return Et(this),this.iHash.update(e),this}digestInto(e){Et(this),he(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:s,finished:r,destroyed:i,blockLen:c,outputLen:o}=this;return e=e,e.finished=r,e.destroyed=i,e.blockLen=c,e.outputLen=o,e.oHash=n._cloneInto(e.oHash),e.iHash=s._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Se=(t,e,n)=>new Be(t,e).update(n).digest();Se.create=(t,e)=>new Be(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function In(t){return{hash:t,hmac:(e,...n)=>Se(t,e,Ze(...n)),randomBytes:be}}function Tn(t,e){const n=s=>An({...t,...In(s)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),vt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ae=BigInt(1),Bt=BigInt(2),ue=(t,e)=>(t+e/Bt)/e;function Ie(t){const e=Tt,n=BigInt(3),s=BigInt(6),r=BigInt(11),i=BigInt(22),c=BigInt(23),o=BigInt(44),a=BigInt(88),f=t*t*t%e,h=f*f*t%e,u=Z(h,n,e)*h%e,y=Z(u,n,e)*h%e,x=Z(y,Bt,e)*f%e,p=Z(x,r,e)*x%e,l=Z(p,i,e)*p%e,g=Z(l,o,e)*l%e,b=Z(g,a,e)*g%e,E=Z(b,o,e)*l%e,B=Z(E,n,e)*h%e,T=Z(B,c,e)*p%e,I=Z(T,s,e)*f%e,m=Z(I,Bt,e);if(!Zt.eql(Zt.sqr(m),t))throw new Error("Cannot find square root");return m}const Zt=wn(Tt,void 0,void 0,{sqrt:Ie}),Jt=Tn({a:BigInt(0),b:BigInt(7),Fp:Zt,n:vt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=vt,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),s=-Ae*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),r=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,c=BigInt("0x100000000000000000000000000000000"),o=ue(i*t,e),a=ue(-s*t,e);let f=P(t-o*n-a*r,e),h=P(-o*s-a*i,e);const u=f>c,y=h>c;if(u&&(f=e-f),y&&(h=e-h),f>c||h>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:f,k2neg:y,k2:h}}}},Mt),Ht=BigInt(0),Te=t=>typeof t=="bigint"&&Ht<t&&t<Tt,Hn=t=>typeof t=="bigint"&&Ht<t&&t<vt,fe={};function St(t,...e){let n=fe[t];if(n===void 0){const s=Mt(Uint8Array.from(t,r=>r.charCodeAt(0)));n=at(s,s),fe[t]=n}return Mt(at(n,...e))}const Xt=t=>t.toRawBytes(!0).slice(1),Wt=t=>st(t,32),Pt=t=>P(t,Tt),yt=t=>P(t,vt),te=Jt.ProjectivePoint,On=(t,e,n)=>te.BASE.multiplyAndAddUnsafe(t,e,n);function Kt(t){let e=Jt.utils.normPrivateKeyToScalar(t),n=te.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:yt(-e),bytes:Xt(n)}}function He(t){if(!Te(t))throw new Error("bad x: need 0 < x < p");const e=Pt(t*t),n=Pt(e*t+BigInt(7));let s=Ie(n);s%Bt!==Ht&&(s=Pt(-s));const r=new te(t,s,Ae);return r.assertValidity(),r}function Oe(...t){return yt(q(St("BIP0340/challenge",...t)))}function $n(t){return Kt(t).bytes}function Un(t,e,n=be(32)){const s=k("message",t),{bytes:r,scalar:i}=Kt(e),c=k("auxRand",n,32),o=Wt(i^q(St("BIP0340/aux",c))),a=St("BIP0340/nonce",o,r,s),f=yt(q(a));if(f===Ht)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=Kt(f),y=Oe(h,r,s),x=new Uint8Array(64);if(x.set(h,0),x.set(Wt(yt(u+y*i)),32),!$e(x,s,r))throw new Error("sign: Invalid signature produced");return x}function $e(t,e,n){const s=k("signature",t,64),r=k("message",e),i=k("publicKey",n,32);try{const c=He(q(i)),o=q(s.subarray(0,32));if(!Te(o))return!1;const a=q(s.subarray(32,64));if(!Hn(a))return!1;const f=Oe(Wt(o),Xt(c),r),h=On(c,a,yt(-f));return!(!h||!h.hasEvenY()||h.toAffine().x!==o)}catch{return!1}}const bt={getPublicKey:$n,sign:Un,verify:$e,utils:{randomPrivateKey:Jt.utils.randomPrivateKey,lift_x:He,pointToBytes:Xt,numberToBytesBE:st,bytesToNumberBE:q,taggedHash:St,mod:P}};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ue=t=>t instanceof Uint8Array,kt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),j=(t,e)=>t<<32-e|t>>>e,Ln=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ln)throw new Error("Non little-endian hardware is not supported");const Nn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function xt(t){if(!Ue(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=Nn[t[n]];return e}function _n(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Le(t){if(typeof t=="string"&&(t=_n(t)),!Ue(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}class Pn{clone(){return this._cloneInto()}}function Ne(t){const e=s=>t().update(Le(s)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Gt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function kn(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function _e(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function qn(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Gt(t.outputLen),Gt(t.blockLen)}function Cn(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function Rn(t,e){_e(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const qt={number:Gt,bool:kn,bytes:_e,hash:qn,exists:Cn,output:Rn};function Mn(t,e,n,s){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,s);const r=BigInt(32),i=BigInt(4294967295),c=Number(n>>r&i),o=Number(n&i),a=s?4:0,f=s?0:4;t.setUint32(e+a,c,s),t.setUint32(e+f,o,s)}class Vn extends Pn{constructor(e,n,s,r){super(),this.blockLen=e,this.outputLen=n,this.padOffset=s,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=kt(this.buffer)}update(e){qt.exists(this);const{view:n,buffer:s,blockLen:r}=this;e=Le(e);const i=e.length;for(let c=0;c<i;){const o=Math.min(r-this.pos,i-c);if(o===r){const a=kt(e);for(;r<=i-c;c+=r)this.process(a,c);continue}s.set(e.subarray(c,c+o),this.pos),this.pos+=o,c+=o,this.pos===r&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){qt.exists(this),qt.output(e,this),this.finished=!0;const{buffer:n,view:s,blockLen:r,isLE:i}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>r-c&&(this.process(s,0),c=0);for(let u=c;u<r;u++)n[u]=0;Mn(s,r-8,BigInt(this.length*8),i),this.process(s,0);const o=kt(e),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,h=this.get();if(f>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)o.setUint32(4*u,h[u],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const s=e.slice(0,n);return this.destroy(),s}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:s,length:r,finished:i,destroyed:c,pos:o}=this;return e.length=r,e.pos=o,e.finished=i,e.destroyed=c,r%n&&e.buffer.set(s),e}}const zn=(t,e,n)=>t&e^~t&n,Zn=(t,e,n)=>t&e^t&n^e&n,Wn=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),et=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),nt=new Uint32Array(64);class Pe extends Vn{constructor(){super(64,32,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){const{A:e,B:n,C:s,D:r,E:i,F:c,G:o,H:a}=this;return[e,n,s,r,i,c,o,a]}set(e,n,s,r,i,c,o,a){this.A=e|0,this.B=n|0,this.C=s|0,this.D=r|0,this.E=i|0,this.F=c|0,this.G=o|0,this.H=a|0}process(e,n){for(let u=0;u<16;u++,n+=4)nt[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const y=nt[u-15],x=nt[u-2],p=j(y,7)^j(y,18)^y>>>3,l=j(x,17)^j(x,19)^x>>>10;nt[u]=l+nt[u-7]+p+nt[u-16]|0}let{A:s,B:r,C:i,D:c,E:o,F:a,G:f,H:h}=this;for(let u=0;u<64;u++){const y=j(o,6)^j(o,11)^j(o,25),x=h+y+zn(o,a,f)+Wn[u]+nt[u]|0,l=(j(s,2)^j(s,13)^j(s,22))+Zn(s,r,i)|0;h=f,f=a,a=o,o=c+x|0,c=i,i=r,r=s,s=x+l|0}s=s+this.A|0,r=r+this.B|0,i=i+this.C|0,c=c+this.D|0,o=o+this.E|0,a=a+this.F|0,f=f+this.G|0,h=h+this.H|0,this.set(s,r,i,c,o,a,f,h)}roundClean(){nt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class Kn extends Pe{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const Gn=Ne(()=>new Pe);Ne(()=>new Kn);var it=Symbol("verified"),jn=t=>t instanceof Object;function Dn(t){if(!jn(t)||typeof t.kind!="number"||typeof t.content!="string"||typeof t.created_at!="number"||typeof t.pubkey!="string"||!t.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(t.tags))return!1;for(let e=0;e<t.tags.length;e++){let n=t.tags[e];if(!Array.isArray(n))return!1;for(let s=0;s<n.length;s++)if(typeof n[s]!="string")return!1}return!0}new TextDecoder("utf-8");var Fn=new TextEncoder;function wt(t){try{t.indexOf("://")===-1&&(t="wss://"+t);let e=new URL(t);return e.pathname=e.pathname.replace(/\/+/g,"/"),e.pathname.endsWith("/")&&(e.pathname=e.pathname.slice(0,-1)),(e.port==="80"&&e.protocol==="ws:"||e.port==="443"&&e.protocol==="wss:")&&(e.port=""),e.searchParams.sort(),e.hash="",e.toString()}catch{throw new Error(`Invalid URL: ${t}`)}}var Yn=class{value;next=null;prev=null;constructor(t){this.value=t}},Qn=class{first;last;constructor(){this.first=null,this.last=null}enqueue(t){const e=new Yn(t);return this.last?this.last===this.first?(this.last=e,this.last.prev=this.first,this.first.next=e):(e.prev=this.last,this.last.next=e,this.last=e):(this.first=e,this.last=e),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const e=this.first;return this.first=null,this.last=null,e.value}const t=this.first;return this.first=t.next,this.first&&(this.first.prev=null),t.value}},Jn=class{generateSecretKey(){return bt.utils.randomPrivateKey()}getPublicKey(t){return xt(bt.getPublicKey(t))}finalizeEvent(t,e){const n=t;return n.pubkey=xt(bt.getPublicKey(e)),n.id=Ct(n),n.sig=xt(bt.sign(Ct(n),e)),n[it]=!0,n}verifyEvent(t){if(typeof t[it]=="boolean")return t[it];const e=Ct(t);if(e!==t.id)return t[it]=!1,!1;try{const n=bt.verify(t.sig,e,t.pubkey);return t[it]=n,n}catch{return t[it]=!1,!1}}};function Xn(t){if(!Dn(t))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content])}function Ct(t){let e=Gn(Fn.encode(Xn(t)));return xt(e)}var Ot=new Jn;Ot.generateSecretKey;Ot.getPublicKey;Ot.finalizeEvent;var ts=Ot.verifyEvent,es=22242;function ns(t,e){if(t.ids&&t.ids.indexOf(e.id)===-1||t.kinds&&t.kinds.indexOf(e.kind)===-1||t.authors&&t.authors.indexOf(e.pubkey)===-1)return!1;for(let n in t)if(n[0]==="#"){let s=n.slice(1),r=t[`#${s}`];if(r&&!e.tags.find(([i,c])=>i===n.slice(1)&&r.indexOf(c)!==-1))return!1}return!(t.since&&e.created_at<t.since||t.until&&e.created_at>t.until)}function ss(t,e){for(let n=0;n<t.length;n++)if(ns(t[n],e))return!0;return!1}function rs(t,e){let n=e.length+3,s=t.indexOf(`"${e}":`)+n,r=t.slice(s).indexOf('"')+s+1;return t.slice(r,r+64)}function is(t){let e=t.slice(0,22).indexOf('"EVENT"');if(e===-1)return null;let n=t.slice(e+7+1).indexOf('"');if(n===-1)return null;let s=e+7+1+n,r=t.slice(s+1,80).indexOf('"');if(r===-1)return null;let i=s+1+r;return t.slice(s+1,i)}function os(t,e){return{kind:es,created_at:Math.floor(Date.now()/1e3),tags:[["relay",t],["challenge",e]],content:""}}async function cs(){return new Promise(t=>{const e=new MessageChannel,n=()=>{e.port1.removeEventListener("message",n),t()};e.port1.addEventListener("message",n),e.port2.postMessage(0),e.port1.start()})}var as=t=>(t[it]=!0,!0),ke=class extends Error{constructor(t,e){super(`Tried to send message '${t} on a closed connection to ${e}.`),this.name="SendingOnClosedConnection"}},qe=class{url;_connected=!1;onclose=null;onnotice=t=>console.debug(`NOTICE from ${this.url}: ${t}`);baseEoseTimeout=4400;connectionTimeout=4400;publishTimeout=4400;openSubs=new Map;connectionTimeoutHandle;connectionPromise;openCountRequests=new Map;openEventPublishes=new Map;ws;incomingMessageQueue=new Qn;queueRunning=!1;challenge;authPromise;serial=0;verifyEvent;_WebSocket;constructor(t,e){this.url=wt(t),this.verifyEvent=e.verifyEvent,this._WebSocket=e.websocketImplementation||WebSocket}static async connect(t,e){const n=new qe(t,e);return await n.connect(),n}closeAllSubscriptions(t){for(let[e,n]of this.openSubs)n.close(t);this.openSubs.clear();for(let[e,n]of this.openEventPublishes)n.reject(new Error(t));this.openEventPublishes.clear();for(let[e,n]of this.openCountRequests)n.reject(new Error(t));this.openCountRequests.clear()}get connected(){return this._connected}async connect(){return this.connectionPromise?this.connectionPromise:(this.challenge=void 0,this.authPromise=void 0,this.connectionPromise=new Promise((t,e)=>{this.connectionTimeoutHandle=setTimeout(()=>{e("connection timed out"),this.connectionPromise=void 0,this.onclose?.(),this.closeAllSubscriptions("relay connection timed out")},this.connectionTimeout);try{this.ws=new this._WebSocket(this.url)}catch(n){clearTimeout(this.connectionTimeoutHandle),e(n);return}this.ws.onopen=()=>{clearTimeout(this.connectionTimeoutHandle),this._connected=!0,this.ws&&this.ws.ping&&this.pingpong(),t()},this.ws.onerror=n=>{clearTimeout(this.connectionTimeoutHandle),e(n.message||"websocket error"),this._connected&&(this._connected=!1,this.connectionPromise=void 0,this.onclose?.(),this.closeAllSubscriptions("relay connection errored"))},this.ws.onclose=n=>{clearTimeout(this.connectionTimeoutHandle),e(n.message||"websocket closed"),this._connected&&(this._connected=!1,this.connectionPromise=void 0,this.onclose?.(),this.closeAllSubscriptions("relay connection closed"))},this.ws.onmessage=this._onmessage.bind(this)}),this.connectionPromise)}async receivePong(){return new Promise((t,e)=>{this.ws&&this.ws.on&&this.ws.on("pong",()=>t(!0))||e("ws can't listen for pong")})}async pingpong(){if(this.ws?.readyState==1){this.ws&&this.ws.ping&&this.ws.ping();const t=await Promise.any([this.receivePong(),new Promise(e=>setTimeout(()=>e(!1),1e4))]);console.error("pingpong result",t),t?setTimeout(()=>this.pingpong(),1e4):this.ws&&this.ws.close()}}async runQueue(){for(this.queueRunning=!0;this.handleNext()!==!1;)await cs();this.queueRunning=!1}handleNext(){const t=this.incomingMessageQueue.dequeue();if(!t)return!1;const e=is(t);if(e){const n=this.openSubs.get(e);if(!n)return;const s=rs(t,"id"),r=n.alreadyHaveEvent?.(s);if(n.receivedEvent?.(this,s),r)return}try{let n=JSON.parse(t);switch(n[0]){case"EVENT":{const s=this.openSubs.get(n[1]),r=n[2];this.verifyEvent(r)&&ss(s.filters,r)&&s.onevent(r);return}case"COUNT":{const s=n[1],r=n[2],i=this.openCountRequests.get(s);i&&(i.resolve(r.count),this.openCountRequests.delete(s));return}case"EOSE":{const s=this.openSubs.get(n[1]);if(!s)return;s.receivedEose();return}case"OK":{const s=n[1],r=n[2],i=n[3],c=this.openEventPublishes.get(s);c&&(clearTimeout(c.timeout),r?c.resolve(i):c.reject(new Error(i)),this.openEventPublishes.delete(s));return}case"CLOSED":{const s=n[1],r=this.openSubs.get(s);if(!r)return;r.closed=!0,r.close(n[2]);return}case"NOTICE":this.onnotice(n[1]);return;case"AUTH":{this.challenge=n[1];return}}}catch{return}}async send(t){if(!this.connectionPromise)throw new ke(t,this.url);this.connectionPromise.then(()=>{this.ws?.send(t)})}async auth(t){const e=this.challenge;if(!e)throw new Error("can't perform auth, no challenge was received");return this.authPromise?this.authPromise:(this.authPromise=new Promise(async(n,s)=>{try{let r=await t(os(this.url,e)),i=setTimeout(()=>{let c=this.openEventPublishes.get(r.id);c&&(c.reject(new Error("auth timed out")),this.openEventPublishes.delete(r.id))},this.publishTimeout);this.openEventPublishes.set(r.id,{resolve:n,reject:s,timeout:i}),this.send('["AUTH",'+JSON.stringify(r)+"]")}catch(r){console.warn("subscribe auth function failed:",r)}}),this.authPromise)}async publish(t){const e=new Promise((n,s)=>{const r=setTimeout(()=>{const i=this.openEventPublishes.get(t.id);i&&(i.reject(new Error("publish timed out")),this.openEventPublishes.delete(t.id))},this.publishTimeout);this.openEventPublishes.set(t.id,{resolve:n,reject:s,timeout:r})});return this.send('["EVENT",'+JSON.stringify(t)+"]"),e}async count(t,e){this.serial++;const n=e?.id||"count:"+this.serial,s=new Promise((r,i)=>{this.openCountRequests.set(n,{resolve:r,reject:i})});return this.send('["COUNT","'+n+'",'+JSON.stringify(t).substring(1)),s}subscribe(t,e){const n=this.prepareSubscription(t,e);return n.fire(),n}prepareSubscription(t,e){this.serial++;const n=e.id||(e.label?e.label+":":"sub:")+this.serial,s=new us(this,n,t,e);return this.openSubs.set(n,s),s}close(){this.closeAllSubscriptions("relay connection closed by us"),this._connected=!1,this.ws?.close(),this.onclose?.()}_onmessage(t){this.incomingMessageQueue.enqueue(t.data),this.queueRunning||this.runQueue()}},us=class{relay;id;closed=!1;eosed=!1;filters;alreadyHaveEvent;receivedEvent;onevent;oneose;onclose;eoseTimeout;eoseTimeoutHandle;constructor(t,e,n,s){this.relay=t,this.filters=n,this.id=e,this.alreadyHaveEvent=s.alreadyHaveEvent,this.receivedEvent=s.receivedEvent,this.eoseTimeout=s.eoseTimeout||t.baseEoseTimeout,this.oneose=s.oneose,this.onclose=s.onclose,this.onevent=s.onevent||(r=>{console.warn(`onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,r)})}fire(){this.relay.send('["REQ","'+this.id+'",'+JSON.stringify(this.filters).substring(1)),this.eoseTimeoutHandle=setTimeout(this.receivedEose.bind(this),this.eoseTimeout)}receivedEose(){this.eosed||(clearTimeout(this.eoseTimeoutHandle),this.eosed=!0,this.oneose?.())}close(t="closed by caller"){if(!this.closed&&this.relay.connected){try{this.relay.send('["CLOSE",'+JSON.stringify(this.id)+"]")}catch(e){if(!(e instanceof ke))throw e}this.closed=!0}this.relay.openSubs.delete(this.id),this.onclose?.(t)}},fs=class{relays=new Map;seenOn=new Map;trackRelays=!1;verifyEvent;trustedRelayURLs=new Set;_WebSocket;constructor(t){this.verifyEvent=t.verifyEvent,this._WebSocket=t.websocketImplementation}async ensureRelay(t,e){t=wt(t);let n=this.relays.get(t);return n||(n=new qe(t,{verifyEvent:this.trustedRelayURLs.has(t)?as:this.verifyEvent,websocketImplementation:this._WebSocket}),n.onclose=()=>{this.relays.delete(t)},e?.connectionTimeout&&(n.connectionTimeout=e.connectionTimeout),this.relays.set(t,n)),await n.connect(),n}close(t){t.map(wt).forEach(e=>{this.relays.get(e)?.close(),this.relays.delete(e)})}subscribe(t,e,n){return n.onauth=n.onauth||n.doauth,this.subscribeMap(t.map(s=>({url:s,filter:e})),n)}subscribeMany(t,e,n){return n.onauth=n.onauth||n.doauth,this.subscribeMap(t.flatMap(s=>e.map(r=>({url:s,filter:r}))),n)}subscribeMap(t,e){e.onauth=e.onauth||e.doauth,this.trackRelays&&(e.receivedEvent=(h,u)=>{let y=this.seenOn.get(u);y||(y=new Set,this.seenOn.set(u,y)),y.add(h)});const n=new Set,s=[],r=[];let i=h=>{r[h]||(r[h]=!0,r.filter(u=>u).length===t.length&&(e.oneose?.(),i=()=>{}))};const c=[];let o=(h,u)=>{c[h]||(i(h),c[h]=u,c.filter(y=>y).length===t.length&&(e.onclose?.(c),o=()=>{}))};const a=h=>{if(e.alreadyHaveEvent?.(h))return!0;const u=n.has(h);return n.add(h),u},f=Promise.all(t.map(async({url:h,filter:u},y)=>{h=wt(h);let x;try{x=await this.ensureRelay(h,{connectionTimeout:e.maxWait?Math.max(e.maxWait*.8,e.maxWait-1e3):void 0})}catch(l){o(y,l?.message||String(l));return}let p=x.subscribe([u],{...e,oneose:()=>i(y),onclose:l=>{l.startsWith("auth-required: ")&&e.onauth?x.auth(e.onauth).then(()=>{x.subscribe([u],{...e,oneose:()=>i(y),onclose:g=>{o(y,g)},alreadyHaveEvent:a,eoseTimeout:e.maxWait})}).catch(g=>{o(y,`auth was required and attempted, but failed with: ${g}`)}):o(y,l)},alreadyHaveEvent:a,eoseTimeout:e.maxWait});s.push(p)}));return{async close(h){await f,s.forEach(u=>{u.close(h)})}}}subscribeEose(t,e,n){n.onauth=n.onauth||n.doauth;const s=this.subscribe(t,e,{...n,oneose(){s.close("closed automatically on eose")}});return s}subscribeManyEose(t,e,n){n.onauth=n.onauth||n.doauth;const s=this.subscribeMany(t,e,{...n,oneose(){s.close("closed automatically on eose")}});return s}async querySync(t,e,n){return new Promise(async s=>{const r=[];this.subscribeEose(t,e,{...n,onevent(i){r.push(i)},onclose(i){s(r)}})})}async get(t,e,n){e.limit=1;const s=await this.querySync(t,e,n);return s.sort((r,i)=>i.created_at-r.created_at),s[0]||null}publish(t,e,n){return t.map(wt).map(async(s,r,i)=>{if(i.indexOf(s)!==r)return Promise.reject("duplicate url");let c=await this.ensureRelay(s);return c.publish(e).catch(async o=>{if(o instanceof Error&&o.message.startsWith("auth-required: ")&&n?.onauth)return await c.auth(n.onauth),c.publish(e);throw o}).then(o=>{if(this.trackRelays){let a=this.seenOn.get(e.id);a||(a=new Set,this.seenOn.set(e.id,a)),a.add(c)}return o})})}listConnectionStatus(){const t=new Map;return this.relays.forEach((e,n)=>t.set(n,e.connected)),t}destroy(){this.relays.forEach(t=>t.close()),this.relays=new Map}},Ce;try{Ce=WebSocket}catch{}var ls=class extends fs{constructor(){super({verifyEvent:ts,websocketImplementation:Ce})}};const hs=new ls,ds=["wss://relay.damus.io","wss://relay.snort.social"],le=document.getElementById("event-list"),Rt=[];hs.subscribe(ds,{kinds:[1],limit:5021},{onevent(t){const e=gs(t.id),n=t.tags.find(r=>r[0]==="nonce"),s=n?parseInt(n[2],10):null;e>0&&s!==null&&e>=s&&(Rt.push({event:t,pow:e,difficulty:s}),Rt.sort((r,i)=>i.pow-r.pow),le.innerHTML="",Rt.forEach(({event:r,pow:i,difficulty:c})=>{const o=document.createElement("div");o.className="note",o.innerHTML=`
            <div><strong>PoW:</strong> ${i} bits</div>
            <div><strong>Public key:</strong> ${r.pubkey}</div>
            <div><strong>Content:</strong> ${r.content}</div>
            <div><strong>Difficulty:</strong> ${c}</div>
          `,le.appendChild(o),console.log(r)}))}});function gs(t){let e=0;for(let n=0;n<t.length;n++){const s=parseInt(t[n],16);if(s===0)e+=4;else{e+=Math.clz32(s)-28;break}}return e}
